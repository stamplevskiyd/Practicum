#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define L 4
#define string_count 2
#define E1 "Dynamic memory error (string)"
#define E2 "Dynamic memory error (array)"

//на момент создания этой записи: работает, ошибок в выводе результата замечено не было. Но нет проверки на NULL в realloc/malloc нигде
//а она должна быть, кстати, еще и при создании p. Непонятно, что по потерям памяти. Рабочая, но очень сырая и недописанная
//на пустом вводе не крашится. если в некоторых строках первый же символ \n, то они ставятся вперед. Логично. Непонятно, стоит ли такие
//строки удалять.

//Beta 5. Пока проблем не обнаружено, кроме того, что первый элемент массива в сортировке не участвует.
//Плюс надо сделать вывод покрасивше, рассмотреть и придумать, как обрабатывать крайние случаи и убрать лишнее в комментариях
//Можно не трогать пустые строки или строки из одних пробелов, но в конце дополнительно сообщать об их наличии
//valgrind-ом пока не протестировано

//Beta-6. Поправлен вывод и баг с первым элементом при сортировке. Добавлены все нужные return-ы.

//Beta-7. Исправлен один баг с выводом. Valgrind запускается. В HEAP все в порядке, в LEAK пишет о потере 2 байт в одном блоке.
//ругается на неинициализированные переменные и использование выражения с p в if(). Ну, это и поправить можно
//может быть, проблема в том, что не освобождается s.

//Bata-8gm. поправлены комментарии, перенесено освобождение p на случай пустого массива. Не готова, но адаптирована для сдачи.

//Beta-9.  Исправлены проблемы с valgrind, переписаны realloc, проблем не обнаружено, сортировка теперь по алфавиту

char* read_str(void);                                          //прототипы функций
void print_array(char**);
void sort_array(char**);

char* read_str (void)                                          //динамическое считывание строки. Кажется, работает
{                                                              //проверка на NULL есть, но непонятно, правильная ли
    int len=L,n,pos=0;
    char *s=NULL;
    if ((s=(char*)malloc(L)))                                  //выделяем под строку начальную динамическую память. Если получается, идем в цикл
    {
        while(fgets(s+pos,L,stdin))                            //сперва прибавляем ноль, считываем строку. Потом когда-нибудь увеличиваем индекс и читаем дальше
        {
            n=strlen(s);                                       //длина строки
            if(s[n-1]!='\n')                                   //если последний считанный! символ строки s-не символ конца. То есть если считали не все.
            {
                pos=n;                                         //увеличиваем адрес начала для нового считывания
                len+=L;                                        //увеличиваем значение длины еще на L
                s=(char*)realloc(s,len);                       //перевыделяем динамическую память
                if (s==NULL)                                   //если встретили "ошибку выделения памяти" на этом этапе, отрабатываем ее через if и выходим из цикла
                {
                    printf("%s\n",E1);
                    break;
                }
            }
            else
            {
                s[n-1]='\0';                                   //ставим символ конца строки, если считали все.
                return s;
            }
        }
    }
    else printf("%s\n",E1);                                    //если выделить динамическую память не удается изначально, при malloc
    free(s);
    return NULL;
}

void print_array(char **p)                                     //вывод результата. Вроде работает
{
    int i=0;
    while(p[i]!=NULL)
    {
        printf("%s\n",p[i]);
        ++i;
    }
    return;
}

void sort_array(char **p)                                      //лексикографическая сортировка массива. Тоже похоже на рабочую
{
    int i,j,k=0;
    while (p[k]!=NULL) ++k;                                    //считаем число значащих строк (то есть кроме последней-NULL)
    for (i=0;i<k-1;i++)                                        //пузырьковая сортировка в лексикографическом порядке (по алфавиту)
    {
        for (j=(k-1);j>i;j--)                                  //есть ли смысл комментировать, как она работает? (может, для наглядности стоит сделать сортировку по длине. Переделать легко
            if (strcmp(p[j-1],p[j])>0)
            {
                char *a;                                       //меняем элементы p (то есть указатели) местами
                a=p[j];
                p[j]=p[j-1];
                p[j-1]=a;
            }
    }
    return;
}

int main()
{
    char **p=(char **)malloc(string_count*sizeof(char**)),*s=NULL;
    int counter=0,size=string_count;
    if(p!=NULL)          //если удается выделить память под массив
    {
        while ((s=read_str()))                           //заполняем массив строками
        {
            if (counter>=size-1)                         //если места не хватит хотя бы под один последний элемент (он будет NULL), то делаем realloc и "добавляем" памяти
            {
                size+=string_count;
                p=(char**)realloc(p,size*sizeof(char*));
                if (*p==NULL)                              //проверка на то, смог ли realloc выделить память
                {
                    printf("%s\n",E2);
                    break;
                }
            }
            p[counter]=s;
            ++counter;
        }
        p[counter]=NULL;                               //зануляем последний элемент массива указателей. Нужно уж как минимум для адекватной работы сортировки и вывода
        printf("___________________\n");
        printf("Initial text\n");
        print_array(p);
        printf("___________________\n");
        printf("Sorted text\n");
        printf("___________________\n");
        sort_array(p);
        print_array(p);
    }
    else printf("%s\n",E2);
    for (int i=0;i<=counter;i++) free(p[i]);               //освобождение памяти. Сперва-строки (то, на что ссылаются элементы массива). Конкретно эта строка, скорее всего, проблем не вызывает (segmentation fault не замечено). Эта строка необходима и работает как надо.
    //предыдущая строка: именно такой вид, такие неравенства. Так нет потерь в HEAP (логично, если задуматься)
    free(p);
    return 0;
}
